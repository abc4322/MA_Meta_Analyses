plot(sav, out = outlier)
}
}
} else {
cat("\nno Gosh plot printed for", moderator.combination, "(linear)\n")
}
}
}
# Polynomial
if (degree.2){
if (interaction){
print("using multiple regression models with interaction ist not implemented yet")
}
degree <- 2
# filter for polynomial regression
if (
is.list(filter.multiple.regression.poly.list) &
if(is.list(filter.multiple.regression.poly.list)){filter.multiple.regression.poly.list[[mod.comb.no]][1] != ""}else{FALSE}
){
regression.df.filtered <- regression.df[filter.multiple.regression.poly.list[[mod.comb.no]],]
} else {
regression.df.filtered <- regression.df
}
# eliminate NAs
regression.df.filtered <- regression.df.filtered %>%
filter(!(
is.na(!!sym(moderator.combination[1])) |
!!sym(moderator.combination[1]) %in% c("NA", nm.placeholder, as.character(nm.placeholder)) |
is.na(!!sym(moderator.combination[2])) |
!!sym(moderator.combination[2]) %in% c("NA", nm.placeholder, as.character(nm.placeholder))
))
if (print.regression.df){
cat("regression data frame for multiple polynomial regression of", moderator.combination, "\n")
print(regression.df.filtered)
}
results.regression.poly <- get.results.metafor(
regression.df.filtered, moderator = moderator.combination, degree = degree
)
# bubble plot
if (print.regplot){
print("bubble plot for multiple polynomial regressions is not implemented yet")
#         ############### TEST for multiple polynomial regression plots ##############
#         for (mod.no in 1:length(moderator.combination)){
#           xvals <- seq(
#             -1,
#             max(regression.df.filtered[
#               which(!is.na(regression.df.filtered[,moderator.combination[mod.no]])),
#               moderator.combination[mod.no]
#             ]) + 5,
#             length=500
#           )
#           sav <- predict(
#             results.regression.poly,
#             newmods = unname(poly(xvals, degree=degree, raw=TRUE))
#           )
#           regplot(
#             results.regression.poly,
#             mod = (mod.no - 1) * degree + 2,
#             refline=0, pred=sav, xvals=xvals, las=1, digits=1, bty="l",
#             xlab = paste(moderator.combination[mod.no], " with follwing fixed: ", moderator.combination[-mod.no], "; polynomial", sep = ""),
#             label=regression.label
#             # xlim = c(0,60), predlim = c(0,60)  # adjusting display area of graph
#           )
#         }
#        ##################################
}
# baujat plot
if (print.baujat.regression){
# par(mar = c(5, 6, 4, 2))  # to set plot parameters?
# plot(influence(results.regression.poly), cex = 0.8, las = 1)
baujat(results.regression.poly, xlab = paste("Squared Pearson Residual (for ", paste(moderator.combination, collapse = ", "), "; Degree: ", degree, ")", sep = ""))
}
# gosh plot
if (print.gosh.regression){
if (
is.list(filter.multiple.regression.poly.list) &
if(is.list(filter.multiple.regression.poly.list)){filter.multiple.regression.poly.list[[mod.comb.no]][1] != ""}else{FALSE}
){
for (outlier in -filter.multiple.regression.poly.list[[mod.comb.no]]){
results.regression.poly.unfiltered <- get.results.metafor(
regression.df, moderator = moderator.combination
)
cat("\n Gosh plot for", paste(moderator.combination, sep = ", "), "(outlier number:", outlier, "; Degree:",degree, ")")
sav <- gosh(results.regression.poly.unfiltered, subsets = 15000)
plot(sav, out = outlier)
}
} else {
cat("\nno Gosh plot printed for", moderator.combination, "(linear)\n")
}
}
}
if (print.regression.results & degree.1){
cat("\nMultiple Regression Results for", moderator.combination, "\n")
if (non.interaction){
print("Multiple Linear (no interaction)")
print(results.regression.linear)
}
if (interaction){
print("Multiple Linear (with interaction)")
print(results.regression.linear.interact)
}
if (degree.2){
cat("\n")
print("Multiple Polynomial")
print(results.regression.poly)
}
}
mod.comb.no <- 1 + 1
}
}
# implement also interaction of moderators?
# calculating regression results was outsourced from meta.analyze() to this function as it occured an unknown error
print.meta.results <- function(
outcome, preferred.scale = FALSE, print.meta.results = TRUE, meta.df.list = FALSE, return.data = FALSE,
# arguments for forest and funnel plot
basic = TRUE,
print.forest = TRUE, print.funnel = TRUE, funnel.label = T, print.influence = TRUE, print.baujat = TRUE, split.subgroups = TRUE, print.forest.sub.single = FALSE,
filter.forest..funnel.vec = FALSE, exclude.high.rob.vec = FALSE,
# basic is to decide if forest and funnel plot shell be printed
# arguments for regression
## (singlie regression)
regression = TRUE,
moderator.vec = c("sessions.duration", "sessions.frequency", "programs.duration", "meditation.total", "follow.up.period", "delivery.mode", "meditation.type"),
regression.degree.1 = TRUE, regression.degree.2 = TRUE, filter.regression.vec = FALSE, print.regression.df = FALSE,
filter.regression.linear.list = FALSE, filter.regression.poly.list = FALSE,
# filter.regression.vec filters regression.df that comes from meta.analyze
# filter.regression.linear/poly.list (filters only linear regression) --> list with filtering vectors in order of moderator.vec ("" means no filtering)
## (additive arguments for multiple regression)
regression.multiple = FALSE,
moderator.multiple.list = FALSE, filter.multiple.regression.linear.list = FALSE, filter.multiple.regression.poly.list = FALSE,
regression.multiple.degree.2 = TRUE, non.interaction = TRUE, interaction = FALSE,
## for both single and multiple regression
print.regression.results = TRUE,  print.regplot = TRUE, print.baujat.regression = TRUE, print.gosh.regression = FALSE, regression.label = FALSE,
without.mean.r = FALSE
){
meditation.type.var <- meditation.type.all
cat("\n#", outcome, "----------------------------------\n")
return.data.var <- NULL
# Forest and Funnel Plot
if (basic){
return.data.var <- meta.analyze(
outcome, meditation.types = meditation.type.var, m.data.list = m.data.list, preferred.scale = preferred.scale, meta.df.list = meta.df.list,
print.forest = print.forest, print.baujat = print.baujat, print.funnel = print.funnel, funnel.label = funnel.label,
print.meta.results = print.meta.results, print.influence = print.influence, return.data = return.data,
filter.forest..funnel.vec = filter.forest..funnel.vec, split.subgroups = split.subgroups, print.forest.sub.single = print.forest.sub.single,
exclude.high.rob.vec = exclude.high.rob.vec, sort.by = "hedges.g", without.mean.r = without.mean.r  # print.descriptive = T
)
}
# Single Regression (one moderator)
if (regression){
mod.no <- 1
# create regression df
for (moderator in moderator.vec){
if (length(moderator.vec) > 1){
print(moderator)
}
regression.df <- meta.analyze(
outcome, meditation.type.var, m.data.list, preferred.scale = preferred.scale, meta.df.list = meta.df.list,
moderator = moderator, filter.regression.vec = filter.regression.vec,
split.subgroups = FALSE, print.influence = FALSE, without.mean.r = without.mean.r
)
if (nrow(regression.df) >= 4){
if (FALSE %in% (regression.df[1,moderator] == regression.df[,moderator])){
# ^ checks if there is more than one equal value present in regression.df[,moderator]
## Linear Regression
if (regression.degree.1){
# filter for linear regression
if (
is.list(filter.regression.linear.list) &
if(is.list(filter.regression.linear.list)){filter.regression.linear.list[[mod.no]][1] != ""}else{FALSE}
){
regression.df.filtered <- regression.df[filter.regression.linear.list[[mod.no]],]
} else {
regression.df.filtered <- regression.df
}
# get results for linear regression
results.regression.linear <- get.results.metafor(
regression.df.filtered, moderator = moderator
)
if (return.data == "regression.results.linear"){
return.data.var <- results.regression.linear
}
for (modertor.label in colnames(regression.labels.df)){
if (moderator == modertor.label){
x.label <- regression.labels.df[1,moderator]
}
}
# bubble plot
if (!moderator %in% c("delivery.mode", "meditation.type") & print.regplot){
regplot(
results.regression.linear,
refline=0,
pi = T,
grid = T,
label = regression.label,
legend = F,
xlab = x.label
# xlim = c(0,60), predlim = c(0,60)  # adjusting display area of graph
)
}
# baujat plot
if (print.baujat.regression){
# outlier analysis
# par(mar = c(5, 6, 4, 2))  # to set plot parameters?
# plot(influence(results.regression.linear), cex = 0.8, las = 1)
if (nrow(regression.df.filtered) > 4){
baujat(results.regression.linear, xlab = paste("Squared Pearson Residual (for ", moderator, "; linear)", sep = ""))
} else {
print("no baujat plot due to less than 5 stuides")
}
}
# gosh plot
if (print.gosh.regression){
if (
is.list(filter.regression.linear.list) &
if(is.list(filter.regression.linear.list)){filter.regression.linear.list[[mod.no]][1] != ""}else{FALSE}
){
for (outlier in -filter.regression.linear.list[[mod.no]]){
results.regression.linear.unfiltered <- get.results.metafor(
regression.df, moderator = moderator
)
cat("\n Gosh plot for", moderator, "(outlier number:", outlier, "linear)")
sav <- gosh(results.regression.linear.unfiltered, subsets = 15000)
plot(sav, out = outlier)
}
} else {
cat("\nno Gosh plot printed for", moderator, "(linear)\n")
}
}
}
## Polynomial Regression
if (regression.degree.2 & moderator %in% moderator.vec[1:4]){
# only for continuous moderators
# filter polynomial regression data
if (
is.list(filter.regression.poly.list) &
if(is.list(filter.regression.poly.list)){filter.regression.poly.list[[mod.no]][1] != ""}else{FALSE}
){
regression.df.filtered <- regression.df[filter.regression.poly.list[[mod.no]],]
} else {
regression.df.filtered <- regression.df
}
for (modertor.label in colnames(regression.labels.df)){
if (moderator == modertor.label){
x.label <- regression.labels.df[1,moderator]
}
}
degree <- 2
# get polynomial regression results
results.regression.polynomial <- get.results.metafor(
regression.df.filtered, moderator = moderator, degree = degree
)
if (return.data == "regression.results.poly"){
return.data.var <- results.regression.polynomial
}
# bubble plot
if (!moderator %in% c("delivery.mode", "meditation.type") & print.regplot){
if (nrow(regression.df.filtered) > 4){
xvals <- seq(-1, max(regression.df.filtered[,moderator]) + 5, length=500)
sav <- predict(results.regression.polynomial, newmods= unname(poly(xvals, degree=degree, raw=TRUE)))
regplot(
results.regression.polynomial, mod=2, pred=sav, xvals=xvals, refline=0, las=1, digits=1, bty="l",
label=regression.label, xlab=x.label,
pi = T, grid = T, legend = F
)
} else {
print("polynomial bubble plot was not printed because number of incluided studies is <= 4")
}
}
# baujat plot
if (print.baujat.regression){
# outlier analysis
# par(mar = c(5, 6, 4, 2))  # to set plot parameters?
# plot(influence(results.regression.polynomial), cex = 0.8, las = 1)
if (nrow(regression.df.filtered) > 4){
baujat(results.regression.polynomial, xlab = paste("Squared Pearson Residual (for ", moderator, "; polynomial)", sep = ""))
} else{
print("no baujat plot due to less than 5 stuides")
}
}
# gosh plot
if (print.gosh.regression){
if (
is.list(filter.regression.poly.list) &
if(is.list(filter.regression.poly.list)){filter.regression.poly.list[[mod.no]][1] != ""}else{FALSE}
){
for (outlier in -filter.regression.poly.list[[mod.no]]){
results.regression.polynomial.unfiltered <- get.results.metafor(
regression.df, moderator = moderator
)
cat("\n Gosh plot for", moderator, "(outlier number:", outlier, "polynomial)")
sav <- gosh(results.regression.polynomial.unfiltered, subsets = 15000)
plot(sav, out = outlier)
}
} else {
cat("\nno Gosh plot printed for", moderator, "(polynomial)\n")
}
}
}
# print regression results
if (print.regression.results){
print(moderator)
print("Linear")
print(results.regression.linear)
if (regression.degree.2){
cat("\n")
print("Polynomial")
print(results.regression.polynomial)
}
}
} else {
print(sprintf('Only equal moderator values present for regression of outcome:"%s" and moderator: "%s"', outcome, moderator))
cat("\n")
}
} else {
print(sprintf('Number of included studies (%d) in regression is below 4 for outcome "%s" and moderator "%s"', nrow(regression.df), outcome, moderator))
cat("\n")
}
# print regression data frame
if(print.regression.df){
print(moderator)
print(regression.df)
}
mod.no <- mod.no + 1
}
}
if (regression.multiple){
do.multiple.regressions(
outcome = outcome, preferred.scale = preferred.scale, meta.df.list = meta.df.list,
moderator.multiple.list = moderator.multiple.list,
filter.multiple.regression.linear.list = filter.multiple.regression.linear.list,
filter.multiple.regression.poly.list = filter.multiple.regression.poly.list,
print.regplot = print.regplot, print.baujat.regression = print.baujat.regression,
print.gosh.regression = print.gosh.regression, print.regression.df = print.regression.df,
regression.label = regression.label, degree.2 = regression.multiple.degree.2,
non.interaction = non.interaction, interaction = interaction
)
}
if (return.data != FALSE){
return(return.data.var)
}
}
# currently with outliers and random effect models
plot.summary.forest <- function(with.outliers = FALSE){
# get total effect sizes and confidence intervals of all outcomes
outcomes <- c()
k <- c()
o <- c()  # total observations
o.i <- c()  # observations in intervention
o.c <- c()  # observations in control
te <- c()
ci.l <- c()
ci.u <- c()
I2 <- c()
pow <- c()
present.outcomes.ordered.te <- present.outcomes
for (outcome in present.outcomes.ordered.te){
if (outcome == "Stress"){
preferred.scale <- "DASS"
} else {
preferred.scale <- FALSE
}
results.meta <- meta.analyze(
outcome = outcome, meditation.types = meditation.type.all, m.data.list = m.data.list,
return.data = "results.meta", preferred.scale = preferred.scale, split.subgroups = FALSE,
filter.forest..funnel.vec = if(length(outlier.list[[outcome]]) > 0 & !with.outliers){-outlier.list[[outcome]]}else{FALSE}
)
if (results.meta$k > 0){
outcomes <- append(outcomes, outcome)
k <- append(
k,
length(unique(
print.meta.results(
outcome, preferred.scale = preferred.scale,
regression = F, print.forest = F, print.funnel = F, print.influence = F, print.baujat = F, split.subgroups = F, print.forest.sub.single = F, print.meta.results = F,
return.data = "meta.df.list"
)[[1]][,1]
))
)
o.i <- append(o.i, sum(results.meta$data[, "n.int"]))
o.c <- append(o.c, sum(results.meta$data[, "n.control"]))
o <- append(
o, sum(results.meta$data[, "n.int"]) + sum(results.meta$data[, "n.control"])
)
te  <- append(te, results.meta$TE.random)
ci.l  <- append(ci.l, results.meta$lower.random)
ci.u <- append(ci.u, results.meta$upper.random)
I2 <- append(I2, results.meta$I2)
pow <- append(pow, results.meta$power)
}
}
df.sum <- data.frame(
outcomes = outcomes,
k = k,
o.i = o.i,
o.c = o.c,
o = o,
te = te,
ci.l = ci.l,
ci.u = ci.u,
I2 = I2,
pow = pow
)
# correct scale  directions
for (outcome in df.sum[,"outcomes"]){
if (outcome.direction.df[outcome.direction.df[,"Outcome"] == outcome, "High.or.low.means.resilient"] == "v"){
df.sum[df.sum[,"outcomes"] == outcome, c("te", "ci.l", "ci.u")] <- -1 * df.sum[df.sum[,"outcomes"] == outcome, c("te", "ci.u", "ci.l")]
}
}
# sort by te
df.sum <- arrange(df.sum, te)
# create col with I^2 is 0 instead of NA
df.sum$I2.trans <- df.sum$I2*100
df.sum[is.na(df.sum$I2.trans), "I2.trans"] <- 0
# roud values
df.sum[,c("o", "te", "ci.l", "ci.u", "I2", "I2.trans", "pow")] <- round(df.sum[,c("o", "te", "ci.l", "ci.u", "I2", "I2.trans", "pow")], 2)
# create col of strings with te an ci vaulues
df.sum$te.ci <- paste(
as.character(df.sum$te), " (",
as.character(df.sum$ci.l), ", ",
as.character(df.sum$ci.u), ")",
sep = ""
)
# create col of strings with observation and no. of studies
df.sum$o.k <- paste(
as.character(df.sum$o), " (",
as.character(df.sum$k), ")",
sep = ""
)
# set band colours for table
df.sum$colour <- rep(c("white", "gray95"), nrow(df.sum) / 2)
#   # correct differece of order due to rounding in band coulor
#   df.sum[df.sum[,"outcomes"] == "Self-efficacy", "colour"] <- "white"
#   df.sum[df.sum[,"outcomes"] == "Self-compassion", "colour"] <- "gray95"
#   df.sum[df.sum[,"outcomes"] == "Mindfulness (trait)", "colour"] <- "white"
#   df.sum[df.sum[,"outcomes"] == "Depression (trait)", "colour"] <- "gray95"
# correct further band coulor
df.sum[df.sum[,"outcomes"] == "Self-efficacy", "colour"] <- "gray95"
df.sum[df.sum[,"outcomes"] == "Self-compassion", "colour"] <- "white"
# set color range for coloring heterogeneity
fun_color_range <- colorRampPalette(c("chartreuse4", "gold", "red"))  # Create color generating function
my_colors <- fun_color_range(20)
my_colors
# forest plot
correct.color.order.forest <- c('white','white','white','gray95','gray95','gray95','white','gray95','white','gray95','gray95','gray95','gray95','white','white','white')
p <- ggplot(df.sum, aes(y = te, x = reorder(outcomes, te))) +
geom_vline(xintercept = outcomes, colour = arrange(df.sum, te)$colour, size = 19) +
geom_pointrange(
aes(
ymin = ci.l, ymax = ci.u, colour = I2.trans, size = o
),
alpha = 0.5, shape = 15
) +
coord_flip() +
guides(colour = guide_legend(override.aes = list(size=0.5)), reverse=TRUE) +
scale_colour_gradientn(colors = my_colors, name="Heterogeneity") +
scale_size_continuous(
name = "Observations", range = c(0.5, 1.7),
breaks = c(
950, 450, 200, 50
)
) +
geom_hline(aes(yintercept=0), colour = 'red', lty=2) +
geom_hline(aes(yintercept=0.2), colour = 'darkgray', lty=3) +
geom_hline(aes(yintercept=0.5), colour = 'darkgray', lty=3) +
geom_hline(aes(yintercept=0.8), colour = 'darkgray', lty=3) +
geom_hline(aes(yintercept=-0.2), colour = 'darkgray', lty=3) +
geom_hline(aes(yintercept=-0.5), colour = 'darkgray', lty=3) +
geom_hline(aes(yintercept=-0.8), colour = 'darkgray', lty=3) +
theme_bw() +
theme(
legend.key=element_rect(fill='cornsilk2'),
axis.text.y = element_blank(), axis.title.y = element_blank(),
axis.text=element_text(size=12), #change font size of axis text
axis.title=element_text(size=12), #change font size of axis titles
plot.title=element_text(size=25)
) +
ggtitle("") + ylab("SMD [Hedge's g]")
# table
font.size <- 5
data_table <- ggplot(data = df.sum, aes(y = reorder(outcomes, te))) +
geom_hline(aes(yintercept = outcomes, colour = colour), size = 19) +
geom_text(aes(x = 0, label = outcomes), hjust = 0, size = font.size) +
geom_text(aes(x = 1, label = o.k), nudge_x = 0.1, hjust = 0, size = font.size) +
geom_text(aes(x = 2, label = te.ci), hjust = 0, nudge_x = - 0.1, size = font.size) +
geom_text(aes(x = 3, label = I2.trans), hjust = 0, nudge_x = - 0.1, size = font.size) +
geom_text(aes(x = 4, label = pow), hjust = 0, nudge_x = - 0.5, size = font.size) +
scale_colour_identity() +
theme_void() +
ggtitle("           Outcome                                                    Oberservations (Studies)       SMD (CI) [Hedge's g]                           I^2 [%]                   Power [%]") +
theme(
plot.margin = margin(5, 0, 39, 0),
plot.title=element_text(size=16, face="bold"),
)
# combine forest plot and table
grid.arrange(
data_table, p, ncol = 2,
widths = c(4/7, 3/7)
)
}
# test
test <- print.meta.results(
"Stress", preferred.scale = "DASS",
regression = F, print.forest = T, print.funnel = F, print.influence = F, print.baujat = F, split.subgroups = F, print.forest.sub.single = F, print.meta.results = F,
return.data = "results.metafor"  # ,
# filter.forest..funnel.vec = outlier.list[[outcome]]
)
reporter(test, dir = "C:\\Users\\anonymous", filename = "Stress_Report", format = "pdf_document", forest = T, funnel = T, open = T, verbose = T, footnotes = T)
reporter(test, filename = "Stress_Report", format = "pdf_document", forest = T, funnel = T, open = T, verbose = T, footnotes = T)
?reporter
reporter(test, filename = "Stress_Report", format = "word_document", forest = T, funnel = T, open = T, verbose = T, footnotes = T)
reporter(test, filename = "Stress_Report", format = "word_document", forest = T, funnel = T, open = T, verbose = T, footnotes = T)
