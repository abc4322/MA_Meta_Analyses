ci.lb = res.obj.interact$ci.lb,
ci.ub = res.obj.interact$ci.ub,
X.mod.1 = res.obj.interact$X[,moderator.combination[1]]
)
model.res.list.interact[[i]] <- res.df.interact
}
}
# combine data from escalc() and regression.df.filtered to data frame and filter out NA for the multiple regression / bubble plot
res.escalc <- escalc(
data = regression.df.filtered, measure = "SMD",
m1i = regression.df.filtered[,"mean.int"], sd1i = regression.df.filtered[,"sd.int"], n1i = regression.df.filtered[,"n.int"],
m2i = regression.df.filtered[,"mean.control"], sd2i = regression.df.filtered[,"sd.control"], n2i = regression.df.filtered[,"n.control"]
)
res.escalc.df <- data.frame(res.escalc[
which(!(
is.na(res.escalc[,moderator.combination[1]]) |
is.na(res.escalc[,moderator.combination[2]])
))
,
])
dat <- regression.df.filtered[
which(!(
is.na(regression.df.filtered[,moderator.combination[1]]) |
is.na(regression.df.filtered[,moderator.combination[2]])
))
,
]
if (non.interaction){
model.res.list[[4]] <- dat[,c("study.id", "hedges.g", "weights", moderator.combination[1], moderator.combination[2])]
# set correct SMD and weights that are used by metafor
model.res.list[[4]]$hedges.g <- res.escalc.df$yi
model.res.list[[4]]$weights <- 1 / res.escalc.df$vi
}
if (interaction){
model.res.list.interact[[4]] <- dat[,c("study.id", "hedges.g", "weights", moderator.combination[1], moderator.combination[2])]
# set correct SMD and weights that are used by metafor
model.res.list.interact[[4]]$hedges.g <- res.escalc.df$yi
model.res.list.interact[[4]]$weights <- 1 / res.escalc.df$vi
}
# get fixed values of moderator 2 that was used for prediction as string to label graphs
mod.fix.val.min <- as.character(round(min(regression.df.filtered[, moderator.combination[2]], na.rm = T), digits = 2))
mod.fix.val.mean <- as.character(round(
(max(regression.df.filtered[, moderator.combination[2]], na.rm = T) + min(regression.df.filtered[, moderator.combination[2]], na.rm = T)) / 2,
digits = 2
))
mod.fix.val.max <- as.character(round(max(regression.df.filtered[, moderator.combination[2]], na.rm = T), digits = 2))
# plot
scale.color.values <- c("red", "blue", "chartreuse3")
names(scale.color.values) <- c(mod.fix.val.min, mod.fix.val.mean, mod.fix.val.max)
if (non.interaction){
print(
ggplot(model.res.list[["min"]], aes(x = X.mod.1, y = pred, group = 1)) +
# 3 regression lines (for low, medium, and high moderator 2 values)
geom_line(aes(col = mod.fix.val.min), size = 1, data = model.res.list[["min"]],) +
geom_ribbon(aes(ymin = ci.lb, ymax = ci.ub), alpha = 0.05, fill = "red", data = model.res.list[["min"]]) +
geom_line(aes(col = mod.fix.val.mean), size = 1, data = model.res.list[["mean"]]) +
geom_ribbon(aes(ymin = ci.lb, ymax = ci.ub), alpha = 0.05, fill = "blue", model.res.list[["mean"]]) +
geom_line(aes(col = mod.fix.val.max), size = 1, data = model.res.list[["max"]]) +
geom_ribbon(aes(ymin = ci.lb, ymax = ci.ub), alpha = 0.05, fill = "chartreuse3", model.res.list[["max"]]) +
# bubbles (SMDs x Moderator 1 x weights)
geom_point(aes(x=!!sym(moderator.combination[1]), y = hedges.g, size = weights), color="darkslategray", alpha = 0.5, data = model.res.list[["data"]]) +
# reference line
geom_hline(yintercept = 0, linetype='dotted') +
# labels
ylab("Standard Mean Difference") +
xlab(moderator.combination[1]) +
labs(title = paste("Multiple Linear Regression Plot of", moderator.combination[1], "and", moderator.combination[2])) +
scale_color_manual(
name = moderator.combination[2], values = scale.color.values,
breaks = c(mod.fix.val.min, mod.fix.val.mean, mod.fix.val.max)
) +
scale_size_continuous(guide = "none")  # +
# coord_cartesian(ylim = c(NA, 0))  # to change display range
)
}
if (interaction){
print(
ggplot(model.res.list.interact[["min"]], aes(x = X.mod.1, y = pred, group = 1)) +
# 3 regression lines (for low, medium, and high moderator 2 values)
geom_line(aes(col = mod.fix.val.min), size = 1, data = model.res.list.interact[["min"]],) +
geom_ribbon(aes(ymin = ci.lb, ymax = ci.ub), alpha = 0.05, fill = "red", data = model.res.list.interact[["min"]]) +
geom_line(aes(col = mod.fix.val.mean), size = 1, data = model.res.list.interact[["mean"]]) +
geom_ribbon(aes(ymin = ci.lb, ymax = ci.ub), alpha = 0.05, fill = "blue", model.res.list.interact[["mean"]]) +
geom_line(aes(col = mod.fix.val.max), size = 1, data = model.res.list.interact[["max"]]) +
geom_ribbon(aes(ymin = ci.lb, ymax = ci.ub), alpha = 0.05, fill = "chartreuse3", model.res.list.interact[["max"]]) +
# bubbles (SMDs x Moderator 1 x weights)
geom_point(aes(x=!!sym(moderator.combination[1]), y = hedges.g, size = weights), color="darkslategray", alpha = 0.5, data = model.res.list.interact[["data"]]) +
# reference line
geom_hline(yintercept = 0, linetype='dotted') +
# labels
ylab("Standard Mean Difference") +
xlab(moderator.combination[1]) +
labs(title = paste(
"Multiple Linear Regression Plot of", moderator.combination[1], "and", moderator.combination[2],
"(with interaction)"
)) +
scale_color_manual(
name = moderator.combination[2], values = scale.color.values,
breaks = c(mod.fix.val.min, mod.fix.val.mean, mod.fix.val.max)
) +
scale_size_continuous(guide = "none")  # +
# coord_cartesian(ylim = c(NA, 0))  # to change display range
)
}
#         ############# TEST to plot multiple regression plot for factors ###############
#         results.regression.linear.cat <- get.results.metafor(
#           regression.df.filtered, moderator = moderator.combination, categorical.mod.trans = T
#         )
#         y.lim.min <- min(results.regression.linear.cat$data$hedges.g)
#         y.lim.max <- max(results.regression.linear.cat$data$hedges.g)
#         plot(
#           coef(results.regression.linear.cat)[1:3], type="o", pch=19,
#           xlim=c(0.8,3.2), ylim=c(y.lim.min,y.lim.max),
#           xlab=moderator.combination[1],
#           ylab="Standardized Mean Difference", xaxt="n", bty="l"
#         )
#         axis(side=1, at=1:3, labels=c("min","mean","max"))
#         lines(
#           coef(results.regression.linear.cat)[1:3] +
#           coef(results.regression.linear.cat)[4], type="o", pch=15, lty="dotted"
#         )
#         legend(
#           "topright", legend=c(paste("min", moderator.combination[2]), paste("max", moderator.combination[2])),
#           lty=c("solid", "dotted"), pch=c(19,15), inset=0.01
#         )
#         title("Estimated Average Effects based on the Additive Model")
#       } else if (print.regplot){
#         print("linear multiple regression plot currently works only with 2 moderators")
#################################
} else if (print.regplot) {
print("printing the bubble plot for multiple linear regressions is only implemented for 2 moderators at once")
}
# baujat plot
if (print.baujat.regression){
# par(mar = c(5, 6, 4, 2))  # to set plot parameters?
# plot(influence(results.regression.linear), cex = 0.8, las = 1)
if (non.interaction){
baujat(results.regression.linear, xlab = paste("Squared Pearson Residual (for ", paste(moderator.combination, collapse = ", "), "; linear)", sep = ""))
}
if (interaction){
if (length(moderator.combination) < 3){
baujat(results.regression.linear.interact, xlab = paste("Squared Pearson Residual (for ", paste(moderator.combination, collapse = ", "), "; linear; with interaction)", sep = ""))
} else {
# for length(moderator.combination) == 3 an error occured with baujat plot, so the hat value and the weights of the influnce() will be used to search for outliers instead
cat("\ninfluence plots of:", moderator.combination)
par(mar = c(5, 6, 4, 2))
plot(influence(results.regression.linear.interact), cex = 0.8, las = 1)
}
}
}
# gosh plot
if (print.gosh.regression){
if (
is.list(filter.multiple.regression.linear.list) &
if(is.list(filter.multiple.regression.linear.list)){filter.multiple.regression.linear.list[[mod.comb.no]][1] != ""}else{FALSE}
){
if (non.interaction){
for (outlier in -filter.multiple.regression.linear.list[[mod.comb.no]]){
results.regression.linear.unfiltered <- get.results.metafor(
regression.df, moderator = moderator.combination
)
cat("\n Gosh plot for", paste(moderator.combination, sep = ", "), "(outlier number:", outlier, "linear)")
sav <- gosh(results.regression.linear.unfiltered, subsets = 15000)
plot(sav, out = outlier)
}
}
if (interaction){
for (outlier in -filter.multiple.regression.linear.list[[mod.comb.no]]){
results.regression.linear.interact.unfiltered <- get.results.metafor(
regression.df, moderator = moderator.combination, interaction = T
)
cat("\n Gosh plot for", paste(moderator.combination, sep = ", "), "(outlier number:", outlier, "linear)")
sav <- gosh(results.regression.linear.interact.unfiltered, subsets = 15000)
plot(sav, out = outlier)
}
}
} else {
cat("\nno Gosh plot printed for", moderator.combination, "(linear)\n")
}
}
}
# Polynomial
if (degree.2){
if (interaction){
print("using multiple regression models with interaction ist not implemented yet")
}
degree <- 2
# filter for polynomial regression
if (
is.list(filter.multiple.regression.poly.list) &
if(is.list(filter.multiple.regression.poly.list)){filter.multiple.regression.poly.list[[mod.comb.no]][1] != ""}else{FALSE}
){
regression.df.filtered <- regression.df[filter.multiple.regression.poly.list[[mod.comb.no]],]
} else {
regression.df.filtered <- regression.df
}
# eliminate NAs
regression.df.filtered <- regression.df.filtered %>%
filter(!(
is.na(!!sym(moderator.combination[1])) |
!!sym(moderator.combination[1]) %in% c("NA", nm.placeholder, as.character(nm.placeholder)) |
is.na(!!sym(moderator.combination[2])) |
!!sym(moderator.combination[2]) %in% c("NA", nm.placeholder, as.character(nm.placeholder))
))
if (print.regression.df){
cat("regression data frame for multiple polynomial regression of", moderator.combination, "\n")
print(regression.df.filtered)
}
results.regression.poly <- get.results.metafor(
regression.df.filtered, moderator = moderator.combination, degree = degree
)
# bubble plot
if (print.regplot){
print("bubble plot for multiple polynomial regressions is not implemented yet")
#         ############### TEST for multiple polynomial regression plots ##############
#         for (mod.no in 1:length(moderator.combination)){
#           xvals <- seq(
#             -1,
#             max(regression.df.filtered[
#               which(!is.na(regression.df.filtered[,moderator.combination[mod.no]])),
#               moderator.combination[mod.no]
#             ]) + 5,
#             length=500
#           )
#           sav <- predict(
#             results.regression.poly,
#             newmods = unname(poly(xvals, degree=degree, raw=TRUE))
#           )
#           regplot(
#             results.regression.poly,
#             mod = (mod.no - 1) * degree + 2,
#             refline=0, pred=sav, xvals=xvals, las=1, digits=1, bty="l",
#             xlab = paste(moderator.combination[mod.no], " with follwing fixed: ", moderator.combination[-mod.no], "; polynomial", sep = ""),
#             label=regression.label
#             # xlim = c(0,60), predlim = c(0,60)  # adjusting display area of graph
#           )
#         }
#        ##################################
}
# baujat plot
if (print.baujat.regression){
# par(mar = c(5, 6, 4, 2))  # to set plot parameters?
# plot(influence(results.regression.poly), cex = 0.8, las = 1)
baujat(results.regression.poly, xlab = paste("Squared Pearson Residual (for ", paste(moderator.combination, collapse = ", "), "; Degree: ", degree, ")", sep = ""))
}
# gosh plot
if (print.gosh.regression){
if (
is.list(filter.multiple.regression.poly.list) &
if(is.list(filter.multiple.regression.poly.list)){filter.multiple.regression.poly.list[[mod.comb.no]][1] != ""}else{FALSE}
){
for (outlier in -filter.multiple.regression.poly.list[[mod.comb.no]]){
results.regression.poly.unfiltered <- get.results.metafor(
regression.df, moderator = moderator.combination
)
cat("\n Gosh plot for", paste(moderator.combination, sep = ", "), "(outlier number:", outlier, "; Degree:",degree, ")")
sav <- gosh(results.regression.poly.unfiltered, subsets = 15000)
plot(sav, out = outlier)
}
} else {
cat("\nno Gosh plot printed for", moderator.combination, "(linear)\n")
}
}
}
if (print.regression.results & degree.1){
cat("\nMultiple Regression Results for", moderator.combination, "\n")
if (non.interaction){
print("Multiple Linear (no interaction)")
print(results.regression.linear)
}
if (interaction){
print("Multiple Linear (with interaction)")
print(results.regression.linear.interact)
}
if (degree.2){
cat("\n")
print("Multiple Polynomial")
print(results.regression.poly)
}
}
mod.comb.no <- 1 + 1
}
}
# implement also interaction of moderators?
# calculating regression results was outsourced from meta.analyze() to this function as it occured an unknown error
print.meta.results <- function(
outcome, preferred.scale = FALSE, print.meta.results = TRUE,
# arguments for forest and funnel plot
basic = TRUE,
filter.forest..funnel.vec = FALSE, exclude.high.rob.vec = FALSE,
return.data = FALSE, split.subgroups = TRUE, print.influence = TRUE,
# basic is to decide if forest and funnel plot shell be printed
# arguments for regression
## (singlie regression)
regression = TRUE,
moderator.vec = c("sessions.duration", "sessions.frequency", "programs.duration", "meditation.total", "follow.up.period", "delivery.mode", "meditation.type"),
regression.degree.2 = TRUE, filter.regression.vec = FALSE, print.regression.df = FALSE,
filter.regression.linear.list = FALSE, filter.regression.poly.list = FALSE,
# filter.regression.vec filters regression.df that comes from meta.analyze
# filter.regression.linear/poly.list (filters only linear regression) --> list with filtering vectors in order of moderator.vec ("" means no filtering)
## (additive arguments for multiple regression)
regression.multiple = FALSE,
moderator.multiple.list = FALSE, filter.multiple.regression.linear.list = FALSE, filter.multiple.regression.poly.list = FALSE,
regression.multiple.degree.2 = TRUE, non.interaction = TRUE, interaction = FALSE,
## for both single and multiple regression
print.regression.results = TRUE,  print.regplot = TRUE, print.baujat.regression = TRUE, print.gosh.regression = FALSE, regression.label = FALSE
){
meditation.type.var <- meditation.type.all
# Forest and Funnel Plot
if (basic){
return.data.var <- meta.analyze(
outcome, meditation.types = meditation.type.var, m.data.list = m.data.list, print.forest = TRUE,
print.funnel = TRUE,  preferred.scale = preferred.scale, sort.by = "hedges.g",
print.meta.results = print.meta.results, print.influence = print.influence, return.data = return.data,
filter.forest..funnel.vec = filter.forest..funnel.vec, split.subgroups = split.subgroups, exclude.high.rob.vec = exclude.high.rob.vec  # print.descriptive = T
)
}
# Single Regression (one moderator)
if (regression){
mod.no <- 1
# create regression df
for (moderator in moderator.vec){
regression.df <- meta.analyze(
outcome, meditation.type.var, m.data.list, preferred.scale = preferred.scale,
moderator = moderator, filter.regression.vec = filter.regression.vec,
split.subgroups = FALSE, print.influence = FALSE
)
if (nrow(regression.df) >= 4){
if (FALSE %in% (regression.df[1,moderator] == regression.df[,moderator])){
# ^ checks if there is more than one equal value present in regression.df[,moderator]
## Linear Regression
# filter for linear regression
if (
is.list(filter.regression.linear.list) &
if(is.list(filter.regression.linear.list)){filter.regression.linear.list[[mod.no]][1] != ""}else{FALSE}
){
regression.df.filtered <- regression.df[filter.regression.linear.list[[mod.no]],]
} else {
regression.df.filtered <- regression.df
}
# get results for linear regression
results.regression.linear <- get.results.metafor(
regression.df.filtered, moderator = moderator
)
# bubble plot
if (!moderator %in% c("delivery.mode", "meditation.type") & print.regplot){
regplot(
results.regression.linear,
refline=0,
label=regression.label
# xlim = c(0,60), predlim = c(0,60)  # adjusting display area of graph
)
}
# baujat plot
if (print.baujat.regression){
# outlier analysis
# par(mar = c(5, 6, 4, 2))  # to set plot parameters?
# plot(influence(results.regression.linear), cex = 0.8, las = 1)
if (nrow(regression.df.filtered) > 4){
baujat(results.regression.linear, xlab = paste("Squared Pearson Residual (for ", moderator, "; linear)", sep = ""))
} else {
print("no baujat plot due to less than 5 stuides")
}
}
# gosh plot
if (print.gosh.regression){
if (
is.list(filter.regression.linear.list) &
if(is.list(filter.regression.linear.list)){filter.regression.linear.list[[mod.no]][1] != ""}else{FALSE}
){
for (outlier in -filter.regression.linear.list[[mod.no]]){
results.regression.linear.unfiltered <- get.results.metafor(
regression.df, moderator = moderator
)
cat("\n Gosh plot for", moderator, "(outlier number:", outlier, "linear)")
sav <- gosh(results.regression.linear.unfiltered, subsets = 15000)
plot(sav, out = outlier)
}
} else {
cat("\nno Gosh plot printed for", moderator, "(linear)\n")
}
}
## Polynomial Regression
if (regression.degree.2 & moderator %in% moderator.vec[1:4]){
# only for continuous moderators
# filter polynomial regression data
if (
is.list(filter.regression.poly.list) &
if(is.list(filter.regression.poly.list)){filter.regression.poly.list[[mod.no]][1] != ""}else{FALSE}
){
regression.df.filtered <- regression.df[filter.regression.poly.list[[mod.no]],]
} else {
regression.df.filtered <- regression.df
}
degree <- 2
# get polynomial regression results
results.regression.polynomial <- get.results.metafor(
regression.df.filtered, moderator = moderator, degree = degree
)
# bubble plot
if (!moderator %in% c("delivery.mode", "meditation.type") & print.regplot){
if (nrow(regression.df.filtered) > 4){
xvals <- seq(-1, max(regression.df.filtered[,moderator]) + 5, length=500)
sav <- predict(results.regression.polynomial, newmods= unname(poly(xvals, degree=degree, raw=TRUE)))
regplot(
results.regression.polynomial, mod=2, pred=sav, xvals=xvals, refline=0, las=1, digits=1, bty="l",
label=regression.label, xlab=moderator, main="Polynomial Model"
)
} else {
print("polynomial bubble plot was not printed because number of incluided studies is <= 4")
}
}
# baujat plot
if (print.baujat.regression){
# outlier analysis
# par(mar = c(5, 6, 4, 2))  # to set plot parameters?
# plot(influence(results.regression.polynomial), cex = 0.8, las = 1)
if (nrow(regression.df.filtered) > 4){
baujat(results.regression.polynomial, xlab = paste("Squared Pearson Residual (for ", moderator, "; polynomial)", sep = ""))
} else{
print("no baujat plot due to less than 5 stuides")
}
}
# gosh plot
if (print.gosh.regression){
if (
is.list(filter.regression.poly.list) &
if(is.list(filter.regression.poly.list)){filter.regression.poly.list[[mod.no]][1] != ""}else{FALSE}
){
for (outlier in -filter.regression.poly.list[[mod.no]]){
results.regression.polynomial.unfiltered <- get.results.metafor(
regression.df, moderator = moderator
)
cat("\n Gosh plot for", moderator, "(outlier number:", outlier, "polynomial)")
sav <- gosh(results.regression.polynomial.unfiltered, subsets = 15000)
plot(sav, out = outlier)
}
} else {
cat("\nno Gosh plot printed for", moderator, "(polynomial)\n")
}
}
}
# print regression results
if (print.regression.results){
print(moderator)
print("Linear")
print(results.regression.linear)
if (regression.degree.2){
cat("\n")
print("Polynomial")
print(results.regression.polynomial)
}
}
} else {
print(sprintf('Only equal moderator values present for regression of outcome:"%s" and moderator: "%s"', outcome, moderator))
cat("\n")
}
} else {
print(sprintf('Number of included studies (%d) in regression is below 3 for outcome "%s" and moderator "%s"', nrow(regression.df), outcome, moderator))
cat("\n")
}
# print regression data frame
if(print.regression.df){
print(moderator)
print(regression.df)
}
mod.no <- mod.no + 1
}
}
if (regression.multiple){
do.multiple.regressions(
outcome = outcome, preferred.scale = preferred.scale, moderator.multiple.list = moderator.multiple.list,
filter.multiple.regression.linear.list = filter.multiple.regression.linear.list,
filter.multiple.regression.poly.list = filter.multiple.regression.poly.list,
print.regplot = print.regplot, print.baujat.regression = print.baujat.regression,
print.gosh.regression = print.gosh.regression, print.regression.df = print.regression.df,
regression.label = regression.label, degree.2 = regression.multiple.degree.2,
non.interaction = non.interaction, interaction = interaction
)
}
if (return.data != FALSE){
return(return.data.var)
}
}
results.metafor.stress.dass <- print.meta.results("Stress", preferred.scale = "DASS", return.data = "results.metafor")
# set plot size
options(repr.plot.width = 10, repr.plot.height = 9, repr.plot.res = 100)
results.metafor.stress.dass <- print.meta.results("Stress", preferred.scale = "DASS", return.data = "results.metafor")
install.packages("shinydashboard")
library(shinydashboard)
library(shiny)
results.meta.stress.dass <- print.meta.results("Stress", preferred.scale = "DASS", return.data = "results.meta")
ui <- dashboardPage(
dashboardHeader(title = "Basic dashboard"),
dashboardSidebar(),
dashboardBody(
# Boxes need to be put in a row (or column)
fluidRow(
box(plotOutput("plot1")),
box(plotOutput("plot2"))
)
)
)
server <- function(input, output) {
output$plot1 <- renderPlot({
test
})
output$plot2 <- renderPlot({
funnel(results.meta.stress.dass)
})
}
shinyApp(ui, server)
