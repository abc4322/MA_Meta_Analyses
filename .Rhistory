position = position_stack(vjust=0.5),
col = c(rep("black", 2), "white"),
size = c(rep(7, 2), 8)
) +  #text within pie pieces
guides(fill = guide_legend(reverse = TRUE, override.aes = list(size = 10))) +  # reverse legend order
labs(
title = "          Frequency of meditation families",
x = NULL, y = NULL, fill = "Meditation families"
) +  # labels
theme_classic() +
theme(
title = element_text(size = 17, face = "bold"),
axis.line = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
legend.text = element_text(size = 17),
legend.title = element_text(size = 17)
) +  # adjust texts
scale_fill_brewer(palette="Blues")  # set color palette
# function checking if value is NA or nm.placeholder
is.na.or.nm <- function(val){
is.na(val) | val %in% c("NA", nm.placeholder, as.character(nm.placeholder))
}
paste(as.character(c(1,3)), collapse = ", ")
# calculate mean sd and range of sessions' duration and frequency and programs duration
sessions.durations.vec <- c()
sessions.durations.report.count <- c()
sessions.frequencies.vec <- c()
sessions.frequencies.report.count <- c()
programs.durations.vec <- c()
programs.durations.report.count <- c()
for (study in 1:study.no){
df <- intervention.comparisons.df.list[[study]]
sessions.durations.report.count <- append(
sessions.durations.report.count,
ifelse(
F %in% is.na.or.nm(df[, "Sessions.Duration.in.minutes"]),
1, 0
)
)
sessions.frequencies.report.count <- append(
sessions.frequencies.report.count,
ifelse(
F %in% is.na.or.nm(df[, "Frequency.in.times.per.week"]),
1, 0
)
)
programs.durations.report.count <- append(
programs.durations.report.count,
ifelse(
F %in% is.na.or.nm(df[, "Total.Duration.in.Days"]),
1, 0
)
)
for (row in 1:nrow(df)){
sessions.duration <- ifelse(is.na.or.nm(df[row, "Sessions.Duration.in.minutes"]), NA, df[row, "Sessions.Duration.in.minutes"])
sessions.durations.vec <- append(sessions.durations.vec, sessions.duration)
sessions.frequency <- ifelse(is.na.or.nm(df[row, "Frequency.in.times.per.week"]), NA, df[row, "Frequency.in.times.per.week"])
sessions.frequencies.vec <- append(sessions.frequencies.vec, sessions.frequency)
programs.duration <- ifelse(is.na.or.nm(df[row, "Total.Duration.in.Days"]), NA, df[row, "Total.Duration.in.Days"])
programs.durations.vec <- append(programs.durations.vec, programs.duration)
}
}
sessions.duration.mean.total <- round(mean(sessions.durations.vec, na.rm = T), digits = 2)
sessions.duration.sd.total <- round(sd(sessions.durations.vec, na.rm = T), digits = 2)
sessions.duration.range.total <- paste(as.character(c(min(sessions.durations.vec, na.rm = T), max(sessions.durations.vec, na.rm = T))), collapse = ", ")
sessions.frequency.mean.total <- round(mean(sessions.frequencies.vec, na.rm = T), digits = 2)
sessions.frequency.sd.total <- round(sd(sessions.frequencies.vec, na.rm = T), digits = 2)
sessions.frequency.range.total <- paste(as.character(c(min(sessions.frequencies.vec, na.rm = T), max(sessions.frequencies.vec, na.rm = T))), collapse = ", ")
programs.duration.mean.total <- round(mean(programs.durations.vec, na.rm = T), digits = 2)
programs.duration.sd.total <- round(sd(programs.durations.vec, na.rm = T), digits = 2)
programs.duration.range.total <- paste(as.character(c(min(programs.durations.vec, na.rm = T), max(programs.durations.vec, na.rm = T))), collapse = ", ")
intervention.characteristics.descriptive.df <- data.frame(
Mean = c(sessions.duration.mean.total, sessions.frequency.mean.total, programs.duration.mean.total),
SD = c(sessions.duration.sd.total, sessions.frequency.sd.total, programs.duration.sd.total),
Range = c(sessions.duration.range.total, sessions.frequency.range.total, programs.duration.range.total),
`Percentage of reporting studies` = round(
c(sum(sessions.durations.report.count), sum(sessions.frequencies.report.count), sum(programs.durations.report.count)) / study.no * 100,
digits = 2
),
row.names = list("Sessions' Duration [minutes]", "Sessions' Frequency [1/week]", "Interventions' Duration [days]")
)
intervention.characteristics.descriptive.df
study.no / c(28, 28)
length(sessions.durations.vec[!is.na.or.nm(sessions.durations.vec)])
length(sessions.frequencies.vec[!is.na.or.nm(sessions.frequencies.vec)])
length(programs.durations.vec[!is.na.or.nm(programs.durations.vec)])
outcomes.no.ordered.freq.df <- outcomes.no.df
outcomes.no.ordered.freq.df <- outcomes.no.df[order(-outcomes.no.df$Freq),]
colnames(outcomes.no.ordered.freq.df) <- c("Outcome", "Frequency")
outcomes.no.ordered.freq.df$`Frequency sufficient data` <- NA
i <- 1
for (outcome in outcomes.no.ordered.freq.df$Outcome){
if (outcome == "stress"){
preferred.scale <- "DASS"
} else {
preferred.scale <- F
}
outcomes.no.ordered.freq.df[i, "Frequency sufficient data"] <-
length(unique(
print.meta.results(
outcome, preferred.scale = preferred.scale,
regression = F, print.forest = F, print.funnel = F, print.influence = F, print.baujat = F, split.subgroups = F, print.forest.sub.single = F, print.meta.results = F,
return.data = "meta.df.list"
)[[1]][,1]
))  # numbers of studies that supply sufficient data for outcomes to caclulate meta-analyses
i <- i + 1
}
outcomes.no.ordered.freq.df$Outcome <- str_to_lower(as.character(outcomes.no.ordered.freq.df$Outcome))
outcomes.no.ordered.freq.df
outcomes.no.ordered.freq.plot.df <- outcomes.no.ordered.freq.df[,c(1,2)]
outcomes.no.ordered.suff.dat.plot.df <- outcomes.no.ordered.freq.df[,c(1,3)]
names(outcomes.no.ordered.suff.dat.plot.df) <- c("Outcome", "Frequency")
outcomes.no.ordered.suff.dat.plot.df$Frequency <- outcomes.no.ordered.freq.plot.df$Frequency - (outcomes.no.ordered.freq.plot.df$Frequency - outcomes.no.ordered.suff.dat.plot.df$Frequency)
outcomes.no.ordered.freq.plot.df$Frequency <- outcomes.no.ordered.freq.plot.df$Frequency - outcomes.no.ordered.suff.dat.plot.df$Frequency
outcomes.no.ordered.freq.plot.df <- rbind(outcomes.no.ordered.suff.dat.plot.df, outcomes.no.ordered.freq.plot.df)
rownames(outcomes.no.ordered.freq.plot.df) <- 1:nrow(outcomes.no.ordered.freq.plot.df)
outcomes.no.ordered.freq.plot.df$`Sufficient data for meta-analysis` <- NA
outcomes.no.ordered.freq.plot.df[1:(nrow(outcomes.no.ordered.freq.plot.df)/2),"Sufficient data for meta-analysis"] <- "yes"
outcomes.no.ordered.freq.plot.df[20:nrow(outcomes.no.ordered.freq.plot.df), "Sufficient data for meta-analysis"] <- "no"
outcomes.no.ordered.freq.plot.df
# set plot size
options(repr.plot.width = 15, repr.plot.height = 9, repr.plot.res = 150)
# # create labels shown in outcome frequency plots
# outcome.freq.labels <- c()
# iter.count <- nrow(outcomes.no.ordered.freq.plot.df)
# for (i in 1:iter.count){
#   if (i <= iter.count / 2){
#     outcome.freq.labels <- append(
#       outcome.freq.labels,
#       outcomes.no.ordered.freq.plot.df[i,"Frequency"] + outcomes.no.ordered.freq.plot.df[i + (iter.count / 2),"Frequency"]  # add number of sufficient and not sufficient data frequency
#     )
#   } else {
#     outcome.freq.labels <- append(outcome.freq.labels, "")
#   }
# }
# outcome.freq.labels
# create labels shown in outcome frequency plots
outcome.freq.labels <- c()
iter.count <- nrow(outcomes.no.ordered.freq.plot.df)
for (i in 1:iter.count){
freq <- outcomes.no.ordered.freq.plot.df[i,"Frequency"]
if (freq == 0){
freq <- ""
}
outcome.freq.labels <- append(
outcome.freq.labels,
freq
)
}
outcome.freq.labels
row.no <- nrow(outcomes.no.ordered.freq.plot.df)
ggplot(outcomes.no.ordered.freq.plot.df, aes(x = reorder(Outcome, -Frequency), y = Frequency, fill = `Sufficient data for meta-analysis`)) +
geom_bar(stat="identity", alpha = 0.6, colour = "white") +
geom_text(
aes(label = outcome.freq.labels),
position = position_stack(vjust=0.5),
color = c(rep("white", length(outcome.freq.labels) / 2), rep("black", length(outcome.freq.labels) / 2))
) +
theme(
title = element_text(size = 16, face = "bold"),
legend.title = element_text(size = 13, face = "bold"),
legend.text = element_text(size = 11),
axis.title = element_text(size = 13, face = "bold"),
axis.text.x = element_text(angle=75, vjust=1, hjust=1, size = 13)
) +
labs(
title = "Frequency of outcomes",
x = "\nOutcomes",
y = "Frequency\n"
) +
scale_fill_manual(values=c("cornflowerblue", "darkblue"))
# split others to an name it
# participants per outcomes (with and without outliers)
part.p.group.p.outcome.df <- data.frame(
Experimental.group = rep(NA, length(present.outcomes)),
Experimental.group.no.outl. = rep(NA, length(present.outcomes)),
Control.group = rep(NA, length(present.outcomes)),
Control.group.no.outl. = rep(NA, length(present.outcomes)),
Total = rep(NA, length(present.outcomes)),
Total.no.outl. = rep(NA, length(present.outcomes)),
row.names = present.outcomes.sorted
)
for (outcome in present.outcomes.sorted){
# get data without outliers
outliers <- outlier.list[[outcome]]
results.meta.wo.o <-  print.meta.results(
outcome, preferred.scale = preferred.scale,
regression = F, print.forest = F, print.funnel = F, print.influence = F, print.baujat = F, split.subgroups = F, print.forest.sub.single = F, print.meta.results = F,
return.data = "results.meta", filter.forest..funnel.vec = if(length(outliers) != 0){-outliers}else{FALSE}
)
n.e.wo.o <- if(results.meta.wo.o$k == 0){0}else{results.meta.wo.o$n.e.pooled}
n.c.wo.o <- if(results.meta.wo.o$k == 0){0}else{results.meta.wo.o$n.c.pooled}
part.p.group.p.outcome.df[outcome, "Experimental.group.no.outl."] <- n.e.wo.o
part.p.group.p.outcome.df[outcome, "Control.group.no.outl."] <- n.c.wo.o
part.p.group.p.outcome.df[outcome, "Total.no.outl."] <- n.e.wo.o + n.c.wo.o
# get data with outliers included
results.meta.w.o <-  print.meta.results(
outcome, preferred.scale = preferred.scale,
regression = F, print.forest = F, print.funnel = F, print.influence = F, print.baujat = F, split.subgroups = F, print.forest.sub.single = F, print.meta.results = F,
return.data = "results.meta"
)
n.e.w.o <- if(results.meta.w.o$k == 0){0}else{results.meta.w.o$n.e.pooled}
n.c.w.o <- if(results.meta.w.o$k == 0){0}else{results.meta.w.o$n.c.pooled}
part.p.group.p.outcome.df[outcome, "Experimental.group"] <- n.e.w.o
part.p.group.p.outcome.df[outcome, "Control.group"] <- n.c.w.o
part.p.group.p.outcome.df[outcome, "Total"] <- n.c.w.o + n.e.w.o
}
# add row with sums
part.p.group.p.outcome.df <- rbind(
part.p.group.p.outcome.df,
data.frame(
part.p.group.p.outcome.df %>%
summarise(across(everything(), ~ sum(., na.rm = TRUE))),
row.names = "Sum"
)
)
part.p.group.p.outcome.df
part.p.group.p.outcome.df$Outcomes <- rownames(part.p.group.p.outcome.df)
part.p.group.p.outcome.df <- part.p.group.p.outcome.df %>%
relocate(Outcomes)
part.p.group.p.outcome.df
# # bring part.p.group.p.outcome.df from wide to long format for plotting (not nessecary)
# part.p.group.p.outcome.gathered.df <- part.p.group.p.outcome.df %>%
#   select(Outcomes:Control.group.no.outl.) %>%
#   filter(!row_number() %in% c(nrow(.))) %>%
#   gather(key = "Groups", value = "Participants", "Experimental.group":"Control.group.no.outl.") %>%
#   mutate(`Outliers included` = ifelse(grepl(".no.outl.", .$Groups), "no", "yes")) %>%
#   mutate(Groups = ifelse(
#       grepl(".no.outl.", .$Groups),
#       sub(".no.outl.", "", .$Groups),
#       .$Groups
#   )) %>%
#   relocate(`Outliers included`, .after = Groups)
# part.p.group.p.outcome.gathered.df
# '''
# row.no <- nrow(part.p.group.p.outcome.gathered.df)
# ggplot(
#   part.p.group.p.outcome.gathered.df,
#   aes(x = reorder(Outcomes, -Participants), y = Participants, fill = `Outliers included`)
# ) +
#   geom_bar(stat="identity", alpha = 0.6, colour = "white") +
#   theme(
#     title = element_text(size = 16, face = "bold"),
#     legend.title = element_text(size = 13, face = "bold"),
#     legend.text = element_text(size = 11),
#     axis.title = element_text(size = 13, face = "bold"),
#     axis.text.x = element_text(angle=75, vjust=1, hjust=1, size = 13)
#   ) +
#   labs(
#     title = "Frequency of Particpimants per Outcome",
#     x = "\nOutcomes",
#     y = "Frequency\n"
#   ) +
#   scale_fill_manual(values=c("cornflowerblue", "darkblue", "blue2", "blue"))
# '''
# ggplot(outcomes.no.ordered.freq.df, aes(x = reorder(Outcome, -Frequency), y = Frequency)) +
#   geom_bar(stat="identity", fill = "cornflowerblue", alpha = 0.6) +
#   theme(
#     title = element_text(size = 16, face = "bold"),
#     axis.title = element_text(size = 13, face = "bold"),
#     axis.text.x = element_text(angle=75, vjust=1, hjust=1, size = 9)
#   ) +
#   labs(
#     title = "Frequency of outcomes",
#     x = "\nOutcomes",
#     y = "Frequency\n"
#   )
# # split others to an name it
get.sens.anal.vec <- function(res){
if ("rma.uni" %in%  class(res)){  # for {metafor} results
n.cont <- sum(res$data[, "n.control"])
n.int <- sum(res$data[, "n.int"])
n.total <- n.cont + n.int
pval <- round(res$pval, 4)
pval <- ifelse(pval == 0, "< .0001" ,pval)
pval.Q <- round(res$QEp, 4)
pval.Q <- ifelse(pval.Q == 0, "< .0001" ,pval.Q)
sens.anal <- c(
res$k, n.total, n.cont, n.int, paste(round(res$b[1,1], 2), " (", round(res$ci.lb, 2), ", ", round(res$ci.ub, 2), ")", sep = ""),
round(res$se, 2), round(res$zval, 2), pval, paste(round(res$tau2, 4), "(- , -)"), round(res$se.tau2, 4),
paste(round(res$I2, 2), "(-, -)"), "-", round(res$QE, 2), pval.Q
)
} else if ("metacont" %in%  class(res)){  # for {meta} resutls
n.cont <- sum(res$n.e)
n.int <- sum(res$n.c)
n.total <- n.cont + n.int
pval <- round(res$pval.random, 4)
pval <- ifelse(pval == 0, "< .0001" ,pval)
pval.Q <- round(res$pval.Q, 4)
pval.Q <- ifelse(pval.Q == 0, "< .0001" ,pval.Q)
sens.anal <- list(
random = c(
res$k, n.total, n.cont, n.int, paste(round(res$TE.random, 2), " (", round(res$lower.random, 2), ", ", round(res$upper.random, 2), ")", sep = ""),
round(res$seTE.random, 2), round(res$zval.random, 2), pval,
paste(round(res$tau2, 4), " (", round(res$lower.tau2, 4), ", ", round(res$upper.tau2, 4), ")", sep = ""), "-",
paste(round(res$I2, 2), " (", round(res$lower.I2, 2), ", ", round(res$upper.I2, 2), ")", sep = ""), "-",
round(res$Q, 2), pval.Q
),
common = c(
res$k, n.total, n.cont, n.int, paste(round(res$TE.common, 2), " (", round(res$lower.common, 2), ", ", round(res$upper.common, 2), ")", sep = ""),
round(res$seTE.common, 2), round(res$zval.common, 2), pval,
paste(round(res$tau2, 4), " (", round(res$lower.tau2, 4), ", ", round(res$upper.tau2, 4), ")", sep = ""), "-",
paste(round(res$I2, 2), " (", round(res$lower.I2, 2), ", ", round(res$upper.I2, 2), ")", sep = ""), "-",
round(res$Q, 2), pval.Q
)
)
} else {
cat("ERROR in get.sens.anal(): unknown input object of class:", class(res))
}
return(sens.anal)
}
get.sens.anal.df <- function(outcome, model, preferred.scale = F){
if (model == "rand.fix"){
outliers <- outlier.list[[outcome]]
restuls.meta.o. <- print.meta.results(
outcome = outcome, preferred.scale = preferred.scale,
regression = F, print.forest = F, print.funnel = F, print.influence = F, print.baujat = F, split.subgroups = F, print.forest.sub.single = F, print.meta.results = F,
return.data = "results.meta"
)
if (restuls.meta.o.$k > 0){
restuls.meta.n.o. <- print.meta.results(
outcome = outcome, preferred.scale = preferred.scale,
regression = F, print.forest = F, print.funnel = F, print.influence = F, print.baujat = F, split.subgroups = F, print.forest.sub.single = F, print.meta.results = F,
return.data = "results.meta",
filter.forest..funnel.vec = if(length(outliers) == 0){FALSE}else{-outliers}
)
restuls.metafor.rand.o. <- print.meta.results(
outcome = outcome, preferred.scale = preferred.scale,
regression = F, print.forest = F, print.funnel = F, print.influence = F, print.baujat = F, split.subgroups = F, print.forest.sub.single = F, print.meta.results = F,
return.data = "results.metafor"
)
restuls.metafor.rand.n.o. <- print.meta.results(
outcome = outcome, preferred.scale = preferred.scale,
regression = F, print.forest = F, print.funnel = F, print.influence = F, print.baujat = F, split.subgroups = F, print.forest.sub.single = F, print.meta.results = F,
return.data = "results.metafor",
filter.forest..funnel.vec = if(length(outliers) == 0){FALSE}else{-outliers}
)
restuls.metafor.fix.o. <- print.meta.results(
outcome = outcome, preferred.scale = preferred.scale,
regression = F, print.forest = F, print.funnel = F, print.influence = F, print.baujat = F, split.subgroups = F, print.forest.sub.single = F, print.meta.results = F,
return.data = "results.metafor", results.metafor.fixed = T,
)
restuls.metafor.fix.n.o. <- print.meta.results(
outcome = outcome, preferred.scale = preferred.scale,
regression = F, print.forest = F, print.funnel = F, print.influence = F, print.baujat = F, split.subgroups = F, print.forest.sub.single = F, print.meta.results = F,
return.data = "results.metafor", results.metafor.fixed = T,
filter.forest..funnel.vec = if(length(outliers) == 0){FALSE}else{-outliers}
)
sens.anal.df <- data.frame(
c(
"number of\nincluded studies", "number of\nobeservations", "... in experimental group", "... in control group", "SMD (CI) [Hedge's g]",
"SMD's standard errror", "SMD's z-value", "p-value\n(testing SMD differs from zero)", "tau^2 (CI)", "tau^2's standard error", "I^2 (CI)", "I^2's standard error", "Q-value", "p-value\n(testing between-study heterogeneity)"
),
get.sens.anal.vec(restuls.meta.o.)[["random"]],
get.sens.anal.vec(restuls.meta.n.o.)[["common"]],
get.sens.anal.vec(restuls.meta.o.)[["random"]],
get.sens.anal.vec(restuls.meta.n.o.)[["common"]],
get.sens.anal.vec(restuls.metafor.rand.o.),
get.sens.anal.vec(restuls.metafor.rand.n.o.),
get.sens.anal.vec(restuls.metafor.fix.o.),
get.sens.anal.vec(restuls.metafor.fix.n.o.)
)
colnames(sens.anal.df) <- c(
"Metrics",
"With outliers and influential cases included (meta; random-effets)",
"With outliers and influential cases excluded (meta; random-effets)",
"With outliers and influential cases included (meta; fixed-effets)",
"With outliers and influential cases excluded (meta; fixed-effets)",
"With outliers and influential cases included (metafor; random-effets)",
"With outliers and influential cases excluded (metafor; random-effets)",
"With outliers and influential cases included (metafor; fixed-effets)",
"With outliers and influential cases excluded (metafor; fixed-effets)"
)
} else {
sens.anal.df <- NA
}
} else if (model == "mixed"){
}
return(sens.anal.df)
}
for (outcome in present.outcomes.sorted){
if (outcome == "Stress"){
for (preferred.scale in c("DASS", "PSS")){
print(preferred.scale)
sens.anal.df <- get.sens.anal.df(outcome, "rand.fix", preferred.scale)
print(sens.anal.df)
}
} else {
sens.anal.df <- get.sens.anal.df(outcome, "rand.fix", F)
print(sens.anal.df)
}
}
# install.packages("gt")  # <-- maniplating table apperance
# install.packages("webshot2")  # <-- for installing PhantomJS
# install phantomjs <-- for saving tables as pictures
# webshot::install_phantomjs(version = "2.1.1",
#                            baseURL = "https://github.com/wch/webshot/releases/download/v0.3.1/",
#                            force = FALSE)
# install.packages("rmarkdown")  # <-- for saving table as docx
library(webshot2)
library(gt)
library(rmarkdown)
test <- get.sens.anal.df("Stress", "rand.fix", "DASS")
test1 <- test |>
gt() |>
data_color(
direction = "row",
palette = "PuOr",
na_color = "white"
)
test1 |> gtsave("test1.png")
chromote::default_chromote_object()
f$close()
f <- chromote::default_chromote_object()
f$close()
test1 |> gtsave("test1.png")
test1 |> gtsave("test1.png")
test1 <- test |>
gt() |>
data_color(
direction = "row",
palette = "viridis",
na_color = "white"
)
test1 |> gtsave("test1.png")
test1 <- test |>
filter(!Metrics)
test1 <- test |>
filter(-Metrics)
test1 <- test |>
filter(!Metrics) |>
gt() |>
data_color(
direction = "row",
palette = "viridis",
na_color = "white"
)
test1 <- test |>
filter(-Metrics) |>
gt() |>
data_color(
direction = "row",
palette = "viridis",
na_color = "white"
)
test1 <- test |>
select(!Metrics) |>
gt() |>
data_color(
direction = "row",
palette = "viridis",
na_color = "white"
)
test1 |> gtsave("test1.png")
test1 <- test |>
set_rownames(.$Metrics) |>
select(!Metrics) |>
gt() |>
data_color(
direction = "row",
palette = "viridis",
na_color = "white"
)
library(magrittr )
test1 <- test |>
set_rownames(.$Metrics) |>
select(!Metrics) |>
gt() |>
data_color(
direction = "row",
palette = "viridis",
na_color = "white"
)
test1 <- test |>
set_rownames(test1$Metrics) |>
select(!Metrics) |>
gt() |>
data_color(
direction = "row",
palette = "viridis",
na_color = "white"
)
test1 |> gtsave("test1.png")
test1 <- test |>
set_rownames(test$Metrics) |>
select(!Metrics) |>
gt() |>
data_color(
direction = "row",
palette = "viridis",
na_color = "white"
) |>
mutate(Metrics = test$Metrics)
test1 <- test |>
gt() |>
data_color(
direction = "row",
palette = "viridis",
na_color = "white",
columns = -c("Metrics")
)
test1 |> gtsave("test1.png")
test |>
gt() |>
data_color(
direction = "row",
palette = "viridis",
na_color = "white",
columns = -c("Metrics")
) |>
gtsave("test1.png")
